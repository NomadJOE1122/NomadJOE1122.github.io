<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据之间的运算 | Like a gust of wind</title><meta name="keywords" content="计算机基础"><meta name="author" content="Chen"><meta name="copyright" content="Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据之间的运算这篇博文将跟随我的脚步去了解计算机数据之间的运算，依据《大学计算机基础教程(第3版)》内容进行学习 数据间运算首先学习计算机运算我们得了解他的构成，计算机数据运算分为算术运算和逻辑运算这两大类 那么数据的运算是在那运行的呢🤔：数据的运算当然是放在计算机的**中央处理器(CPU)里面执行的啦,而在CPU中我们有专门的部件来完成算术和逻辑运算，这个部件叫做算术逻辑单元 (ALU: Ar">
<meta property="og:type" content="article">
<meta property="og:title" content="数据之间的运算">
<meta property="og:url" content="https://nomadjoe1122.github.io/2021/09/26/%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97/index.html">
<meta property="og:site_name" content="Like a gust of wind">
<meta property="og:description" content="数据之间的运算这篇博文将跟随我的脚步去了解计算机数据之间的运算，依据《大学计算机基础教程(第3版)》内容进行学习 数据间运算首先学习计算机运算我们得了解他的构成，计算机数据运算分为算术运算和逻辑运算这两大类 那么数据的运算是在那运行的呢🤔：数据的运算当然是放在计算机的**中央处理器(CPU)里面执行的啦,而在CPU中我们有专门的部件来完成算术和逻辑运算，这个部件叫做算术逻辑单元 (ALU: Ar">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nomadjoe1122.github.io/img/wallhaven-8orrgj.jpg">
<meta property="article:published_time" content="2021-09-26T02:34:04.000Z">
<meta property="article:modified_time" content="2021-09-26T08:11:10.529Z">
<meta property="article:author" content="Chen">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nomadjoe1122.github.io/img/wallhaven-8orrgj.jpg"><link rel="shortcut icon" href="/img/wallhaven-4dl1m3.jpg"><link rel="canonical" href="https://nomadjoe1122.github.io/2021/09/26/%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Chen","link":"链接: ","source":"来源: Like a gust of wind","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据之间的运算',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-26 16:11:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/wallhaven-4dl1m3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fas fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/wallhaven-8orrgj.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Like a gust of wind</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fas fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据之间的运算</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-26T02:34:04.000Z" title="发表于 2021-09-26 10:34:04">2021-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-26T08:11:10.529Z" title="更新于 2021-09-26 16:11:10">2021-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据之间的运算"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="数据之间的运算"><a href="#数据之间的运算" class="headerlink" title="数据之间的运算"></a>数据之间的运算</h2><p><strong>这篇博文将跟随我的脚步去了解计算机数据之间的运算，依据《大学计算机基础教程(第3版)》内容进行学习</strong></p>
<h3 id="数据间运算"><a href="#数据间运算" class="headerlink" title="数据间运算"></a>数据间运算</h3><p>首先学习计算机运算我们得了解他的构成，计算机数据运算分为<strong>算术运算</strong>和<strong>逻辑运算</strong>这两大类</p>
<p>那么数据的运算是在那运行的呢🤔：数据的运算当然是放在计算机的**中央处理器(CPU)<strong>里面执行的啦,而在CPU中我们有专门的部件来完成算术和逻辑运算，这个部件叫做</strong>算术逻辑单元 (ALU: Arithmetic Logic Unit)**，我们重点展开讲一下ALU这个部件有关于它的基本知识。🙉🙉🙉</p>
<h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4><p>它是数字电子电路的合并形式，它对整数二进制数执行算术和按位运算。 这与**浮点运算单元(FPU: Float Point Unit)**相比，后者在浮点数上运行并起作用。 <strong>ALU</strong>是各种类型的计算电路的基本组成部分</p>
<p>其中包括：</p>
<ul>
<li><p>The central processing unit (CPU) of computers</p>
<p>计算机的中央处理器(CPU)</p>
</li>
<li><p>FPUs</p>
<p>FPU</p>
</li>
<li><p>Graphics processing units (GPUs)</p>
<p>图形处理单元(GPU)</p>
</li>
</ul>
<p>单个CPU，FPU或GPU可能包含各种ALU</p>
<h5 id="ALU功能-ALU-Functions"><a href="#ALU功能-ALU-Functions" class="headerlink" title="ALU功能(ALU Functions)"></a>ALU功能(ALU Functions)</h5><p><strong>ALU</strong>通常支持一些基本的算术和按位逻辑函数。 基本的通用<strong>ALU</strong>通常包含以下操作：</p>
<ul>
<li><p><strong>Add</strong>: A and B are summed and the sum comes out at Y and carry-out.</p>
<p><strong>加</strong> ：将A和B相加，并且总和在Y处并结转。</p>
</li>
<li><p><strong>Add with carry</strong>: A, B and carry-in are summed and the sum comes out at Y and carry-out.</p>
<p><strong>带进位</strong>加法：将A，B和进位相加，总和在Y处进行进位。</p>
</li>
<li><p><strong>Subtract</strong>: B is subtracted from A (or vice versa) and the difference comes out at Y and carry-out. For this function, carry-out is efficiently a “borrow” indicator. This operation may also be used to contrast the magnitudes of A and B; in such conditions, the Y output may be unnoticed by the processor, which is only involved in the status bits (specifically zero and negative) that outcome from the operation.</p>
<p><strong>减法</strong> ：从A中<strong>减去</strong> B(反之亦然)，并且差在Y处出现并结转。 对于此功能，结转实际上是“借入”指示器。 此操作也可以用来对比A和B的大小； 在这种情况下，处理器可能不会注意到Y输出，该处理器仅涉及操作产生的状态位(特别是零和负)。</p>
</li>
<li><p><strong>Subtract with borrow</strong>: B is subtracted from A (or vice versa) with borrow (carry-in) and the difference comes out at Y and carry-out (borrow out).</p>
<p><strong>用借位减去</strong> ：用借位(进位)从A中减去B(反之亦然)，差值在Y处出现，而结转(借入)。</p>
<p>Two’s complement (negate): A (or B) is subtracted from zero and the difference comes out at Y.</p>
<p>二进制补码(取反)：从零中减去A(或B)，并且差在Y处出现。</p>
</li>
<li><p><strong>Increment</strong>: A (or B) is increased by one and the outcome value comes out at Y.</p>
<p><strong>增量</strong> ：A(或B)增加一，结果值显示为Y。</p>
</li>
<li><p><strong>Decrement</strong>: A (or B) is decreased by one and the outcome value comes out at Y.</p>
<p><strong>减量</strong> ：A(或B)减一，结果值为Y。</p>
</li>
<li><p><strong>Pass through</strong>: all bits of A (or B) appear unchanged at Y. This operation is normally used to find out the state of correspondence of the operand or whether it is zero or negative or to put up the operand into a processor register.</p>
<p><strong>直通</strong> ：A(或B)的所有位在Y处均保持不变。此操作通常用于查找操作数的对应状态，或者它是零还是负数，或将操作数放入处理器寄存器中。</p>
</li>
</ul>
<h5 id="按位逻辑运算-Bitwise-logical-operations"><a href="#按位逻辑运算-Bitwise-logical-operations" class="headerlink" title="按位逻辑运算 **(**Bitwise logical operations)"></a>按位逻辑运算 **(**Bitwise logical operations)</h5><ul>
<li><p><strong>AND</strong>: the bitwise AND of A and B comes out at Y.</p>
<p><strong>AND</strong> ：A和B的按位与在Y处出现。</p>
</li>
<li><p><strong>OR</strong>: the bitwise OR of A and B come out at Y.</p>
<p><strong>OR</strong> ：A和B的按位OR在Y处出现。</p>
</li>
<li><p><strong>Exclusive-OR</strong>: the bitwise XOR of A and B come out at Y.</p>
<p>异<strong>或</strong> ：A和B的按位XOR在Y处出现。</p>
</li>
<li><p><strong>Ones’ complement</strong>: all bits of A (or B) are inverted and come out at Y.</p>
<p><strong>一个补码</strong> ：A(或B)的所有位都反转并在Y处出现。</p>
</li>
</ul>
<h5 id="移位操作-Bit-shift-operations"><a href="#移位操作-Bit-shift-operations" class="headerlink" title="移位操作 (Bit shift operations)"></a>移位操作 (Bit shift operations)</h5><ul>
<li><p><strong>Arithmetic shift</strong>: the operand is taken care of as a two’s complement integer, signifying that the highly noteworthy bit is a “sign” bit and is preserved.</p>
<p><strong>算术移位</strong> ：操作数被视为二进制补码整数，表示高度值得注意的位是“符号”位并被保留。</p>
</li>
<li><p><strong>Logical shift</strong>: a logic zero is shifted into the operand. This is used to shift unsigned integers.</p>
<p><strong>逻辑移位</strong> ：将逻辑零移位到操作数中。 这用于移位无符号整数。</p>
</li>
<li><p><strong>Rotate</strong>: the operand is taken care of as a circular buffer of bits so it’s smallest and highly noteworthy bits are successfully adjacent.</p>
<p><strong>旋转</strong> ：操作数被当作位的循环缓冲区处理，因此它最小且值得注意的位成功相邻。</p>
</li>
<li><p><strong>Rotate through carry</strong>: the carry bit and operand are cooperatively taken care of as a circular buffer of bits.</p>
<p><strong>循环</strong>进位：将进位和操作数作为位的循环缓冲区共同处理。</p>
</li>
</ul>
<p>参考： <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">Arithmetic_logic_unit</a></p>
<h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>算术运算包括加，减，乘，除，求补和算术移位等。</p>
<p>首先我们从补码的加，减运算入手</p>
<h4 id="补码加减运算"><a href="#补码加减运算" class="headerlink" title="补码加减运算"></a>补码加减运算</h4><p>补码运算规则简单，计算机中大量采用。</p>
<h5 id="1-补码加法运算"><a href="#1-补码加法运算" class="headerlink" title="1.补码加法运算"></a>1.补码加法运算</h5><p>两个相加的数无论正负，只要表示成对应的补码形式，则可直接按二进制规则相加，且符号位作为数的一部分直接参与运算，所得结果就是和的补码形式，用关系式表示<br>$$<br>[x]补 + [y]补 = [x+y]补<br>$$<br>结论：用补码表示的数据进行加法算时可以不考虑符号位，直接运算，即与不带符号的数据的运算完全相同。</p>
<h5 id="2-补码减法运算"><a href="#2-补码减法运算" class="headerlink" title="2.补码减法运算"></a>2.补码减法运算</h5><p>例如：</p>
<p>56-34</p>
<p>​    00111000</p>
<p>–  00100010</p>
<p>————————</p>
<p>00010110 = 22</p>
<p>在计算机实际处理的时候并没有直接坐减法运算而是将减法运算转换成加法运算来处理，这就是为什么采用补码来表示带符号数的一个重要原因，在微机系统中之所以采用补码来表示带符号数，就是因为当用补码来表示带符号数的时候可以将减法运算转换成加法运算，这样在涉及到CPU内部运算器时就可以只考虑加法器，那这样呢硬件线路简单，运行速度快，将减法转加法如下</p>
<p>$$<br>[x-y]补 = [x+(-y)]补 = [x]补 + [-y]补<br>$$<br>[-y]补称为[y]补的机器负数。</p>
<p>不管 y的真值是正数还是负数，已知 [y]补求机器负数[-y]补的方法是：将[y]补连同符号位一起变反，末尾加1（定点小数中这个1就是2的-n次方）。</p>
<h5 id="3-补码的运算规则"><a href="#3-补码的运算规则" class="headerlink" title="3.补码的运算规则"></a>3.补码的运算规则</h5><ol>
<li>参与运算的操作数用补码表示</li>
<li>符号位参加运算</li>
<li>若指令操作码为加，则两数直接相加；若操作码为减，则将减数连同符号位一起变反加1后再与被减数相加</li>
<li>运算结果用补码表示</li>
</ol>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong>例题</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例题：[x]补=00110110，[y]补=11001101；求[x-y]补？</span><br><span class="line"></span><br><span class="line">（1）[x]补=00110110，[y]补=11001101；</span><br><span class="line"></span><br><span class="line">（2）[-y]补=00110010+1=00110011;</span><br><span class="line"></span><br><span class="line">（3) [x-y]补=00110011;</span><br></pre></td></tr></table></figure>

<h4 id="算术移位"><a href="#算术移位" class="headerlink" title="算术移位"></a>算术移位</h4><p>算术移位又分为<strong>算术左移</strong>和<strong>算术右移</strong></p>
<p><strong>算术左移</strong>：所有位向左移一位，最高位丢弃，最低位补0。</p>
<p>算术左移n位相当于给该数乘以2n。</p>
<p><strong>算术右移</strong>：所有位向右移一位，最低位丢弃，最高位补符号位。</p>
<p>算术右移n位相当于给该数整除以2n。</p>
<h4 id="运算溢出及判断"><a href="#运算溢出及判断" class="headerlink" title="运算溢出及判断"></a>运算溢出及判断</h4><p>算术运算时，若运算结果超出所能表示的数据范围，则称为溢出。</p>
<p>用双符号位发判断是否溢出，结果双符号位：</p>
<p>00：无溢出，结果为正数</p>
<p>01：上溢(结果大于最大正数)</p>
<p>10：下溢(结果小于最小负数)</p>
<p>11：无溢出，结果为负数</p>
<p>发生溢出时结果错误，需要进行异常处理</p>
<h5 id="加法溢出"><a href="#加法溢出" class="headerlink" title="加法溢出"></a>加法溢出</h5><p>运算结果超出了目标所能容纳的范围，称发生了溢出。</p>
<p>例如：</p>
<p>8位所能表示的补码数据的范围是：-128~+127</p>
<p>只有两个同号数相加时，才有可能发生溢出。即：两个同号数相加，结果的符号位和运算数的符号位不同，则发生了溢出</p>
<h5 id="减法溢出"><a href="#减法溢出" class="headerlink" title="减法溢出"></a>减法溢出</h5><p>运算结果超出了目标所能容纳的范围，称发生了溢出。</p>
<p>只有两个异号数相减时，才有可能发生溢出。即：两个异号数相减，结果的符号位和被减数的符号位不同，则发生了溢出。</p>
<p>对-128取补，会发生溢出。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nomadjoe1122.github.io/2021/09/26/%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97/">https://nomadjoe1122.github.io/2021/09/26/%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://NomadJOE1122.github.io" target="_blank">Like a gust of wind</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></div><div class="post_share"><div class="social-share" data-image="/img/wallhaven-8orrgj.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/09/21/ViewPager%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C/"><img class="next-cover" src="/img/wallhaven-zxgv5o.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ViewPager实现滑动效果</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">1.</span> <span class="toc-text">数据之间的运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%97%B4%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.</span> <span class="toc-text">数据间运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ALU"><span class="toc-number">1.1.1.</span> <span class="toc-text">ALU</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ALU%E5%8A%9F%E8%83%BD-ALU-Functions"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">ALU功能(ALU Functions)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97-Bitwise-logical-operations"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">按位逻辑运算 **(**Bitwise logical operations)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C-Bit-shift-operations"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">移位操作 (Bit shift operations)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.</span> <span class="toc-text">算术运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.1.</span> <span class="toc-text">补码加减运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%A1%A5%E7%A0%81%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.补码加法运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%A1%A5%E7%A0%81%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.补码减法运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%A1%A5%E7%A0%81%E7%9A%84%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3.补码的运算规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">算术移位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E6%BA%A2%E5%87%BA%E5%8F%8A%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.3.</span> <span class="toc-text">运算溢出及判断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">加法溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E6%B3%95%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">减法溢出</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/wallhaven-8orrgj.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 By Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thank you for reading my webblog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'qpeqOKpEKNAXdA2hqTCJbznK-gzGzoHsz',
      appKey: 'efgxpYuaClUA9QWRBMsAQdtw',
      placeholder: '记得留下你的昵称和邮箱喔...可以更快收到回复',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>